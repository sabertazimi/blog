---
layout: post
title: 'TypeScript Basic Notes'
subtitle: 'TypeScript Basic Notes'
author: 'Sabertaz'
date: 2022-05-05
header-img: '/images/landing.jpg'
tags:
  - TypeScript
  - JavaScript
  - Frontend Development
  - Web Development
---

# TypeScript Basic Notes

## Modules

### Classic Module Resolution

`import { a } from './module'`:

- `/root/src/folder/module.ts`.
- `/root/src/folder/module.d.ts`.

`import { a } from 'module'`:

- `/root/src/folder/module.ts`.
- `/root/src/folder/module.d.ts`.
- `/root/src/module.ts`.
- `/root/src/module.d.ts`.
- `/root/module.ts`.
- `/root/module.d.ts`.
- `/module.ts`.
- `/module.d.ts`.

### Node Module Resolution

`const x = require('./module')`:

- `/root/src/module.ts`.
- `/root/src/module.tsx`.
- `/root/src/module.d.ts`.
- `/root/src/module/package.json` + `{ "types": "lib/mainModule.ts" }`
  = `/root/src/module/lib/mainModule.ts`.
- `/root/src/module/index.ts`.
- `/root/src/module/index.tsx`.
- `/root/src/module/index.d.ts`.

`const x = require('module')`:

- `/root/src/node_modules/module.ts`.
- `/root/src/node_modules/module.tsx`.
- `/root/src/node_modules/module.d.ts`.
- `/root/src/node_modules/module/package.json` (if it specifies a `types` property).
- `/root/src/node_modules/@types/module.d.ts`.
- `/root/src/node_modules/module/index.ts`.
- `/root/src/node_modules/module/index.tsx`.
- `/root/src/node_modules/module/index.d.ts`.
- `/root/node_modules/module.ts`.
- `/root/node_modules/module.tsx`.
- `/root/node_modules/module.d.ts`.
- `/root/node_modules/module/package.json` (if it specifies a `types` property).
- `/root/node_modules/@types/module.d.ts`.
- `/root/node_modules/module/index.ts`.
- `/root/node_modules/module/index.tsx`.
- `/root/node_modules/module/index.d.ts`.
- `/node_modules/module.ts`.
- `/node_modules/module.tsx`.
- `/node_modules/module.d.ts`.
- `/node_modules/module/package.json` (if it specifies a `types` property).
- `/node_modules/@types/module.d.ts`.
- `/node_modules/module/index.ts`.
- `/node_modules/module/index.tsx`.
- `/node_modules/module/index.d.ts`.

## Enum Types

`const` enums don’t have representation at runtime,
its member values are used directly.

```ts
// Source code:
const enum NoYes {
  No,
  Yes,
}

function toGerman(value: NoYes) {
  switch (value) {
    case NoYes.No:
      return 'Neither';
    case NoYes.Yes:
      return 'Ja';
  }
}

// Compiles to:
function toGerman(value) {
  switch (value) {
    case 'No' /* No */:
      return 'Neither';
    case 'Yes' /* Yes */:
      return 'Ja';
  }
}
```

Non-const enums are objects:

```ts
// Source code:
enum Tristate {
  False,
  True,
  Unknown,
}

// Compiles to:
let Tristate;
(function (Tristate) {
  Tristate[(Tristate.False = 0)] = 'False';
  Tristate[(Tristate.True = 1)] = 'True';
  Tristate[(Tristate.Unknown = 2)] = 'Unknown';
})(Tristate || (Tristate = {}));

console.log(Tristate[0]); // 'False'
console.log(Tristate.False); // 0
console.log(Tristate[Tristate.False]); // 'False' because `Tristate.False == 0`
```

```ts
enum NoYes {
  No = 'NO!',
  Yes = 'YES!',
}

let NoYes;
(function (NoYes) {
  NoYes.No = 'NO!';
  NoYes.Yes = 'YES!';
})(NoYes || (NoYes = {}));
```

## Interface

- Type aliases may not participate in declaration merging, but interfaces can.
- Interfaces may only be used to declare the shapes of object, not re-name primitives.
- The key distinction is that a type cannot be re-opened to add new properties,
  an interface which is always extendable.

```ts
interface Window {
  title: string;
}

interface Window {
  ts: TypeScriptAPI;
}

const src = 'const a = "Hello World"';
window.ts.transpileModule(src, {});
```

## Index Signature

```ts
const MyArray = [
  { name: 'Alice', age: 15 },
  { name: 'Bob', age: 23 },
  { name: 'Eve', age: 38 },
];

type Person = typeof MyArray[number];
// type Person = {
//   name: string;
//   age: number;
// }

type Age = typeof MyArray[number]['age'];
// type Age = number

type Age2 = Person['age'];
// type Age2 = number
```

`{ [K in keyof T]: indexedType }[keyof T]` 返回键名 (键名组成的联合类型):

```ts
type PickByValueType<T, ValueType> = Pick<
  T,
  { [K in keyof T]-?: T[K] extends ValueType ? K : never }[keyof T]
>;

type OmitByValueType<T, ValueType> = Pick<
  T,
  { [K in keyof T]-?: T[K] extends ValueType ? never : K }[keyof T]
>;

type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];

type OptionalKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;
}[keyof T];

type FunctionTypeKeys<T extends object> = {
  [K in keyof T]-?: T[K] extends Function ? K : never;
}[keyof T];

type Filter<T extends object, ValueType> = {
  [K in keyof T as ValueType extends T[K] ? K : never]: T[K];
}; // Filter<{name: string; id: number;}, string> => {name: string;}
```

## Template Literal Types

- Based on literal types.
- 4 intrinsic String Manipulation Types:
  - `Uppercase<StringType>`.
  - `Lowercase<StringType>`.
  - `Capitalize<StringType>`.
  - `Uncapitalize<StringType>`.

```ts
interface PropEventSource<Type> {
  on<Key extends string & keyof Type>(
    eventName: `${Key}Changed`,
    callback: (newValue: Type[Key]) => void
  ): void;
}

// Create a "watched object" with an 'on' method
// so that you can watch for changes to properties.
declare function makeWatchedObject<Type>(
  obj: Type
): Type & PropEventSource<Type>;

const person = makeWatchedObject({
  firstName: 'Yi',
  lastName: 'Long',
  age: 26,
});

person.on('firstNameChanged', newName => {
  // (parameter) newName: string
  console.log(`new name is ${newName.toUpperCase()}`);
});

person.on('ageChanged', newAge => {
  // (parameter) newAge: number
  if (newAge < 0) {
    console.warn('warning! negative age');
  }
});

// It's typo-resistent
person.on('firstName', () => {});
// Argument of type '"firstName"' is not assignable to
// parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.

person.on('fstNameChanged', () => {});
// Argument of type '"fstNameChanged"' is not assignable to
// parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.
```

## Generic Types

```ts
interface Lengthwise {
  length: number;
}

function createList<T extends number | Lengthwise>(): T[] {
  return [] as T[];
}

const numberList = createList<number>(); // ok
const stringList = createList<string>(); // ok
const arrayList = createList<any[]>(); // ok
const boolList = createList<boolean>(); // error
```

在类型编程里, 泛型就是变量:

```ts
function pick<T extends object, U extends keyof T>(obj: T, keys: U[]): T[U][] {
  return keys.map(key => obj[key]);
}
```

## Union Types

```ts
interface Square {
  kind: 'square';
  size: number;
}

interface Rectangle {
  kind: 'rectangle';
  width: number;
  height: number;
}

interface Circle {
  kind: 'circle';
  radius: number;
}

type Shape = Square | Rectangle | Circle;

function area(s: Shape) {
  switch (s.kind) {
    case 'square':
      return s.size * s.size;
    case 'rectangle':
      return s.width * s.height;
    case 'circle':
      return Math.PI * s.radius ** 2;
    default: {
      const _exhaustiveCheck: never = s;
      return _exhaustiveCheck;
    }
  }
}
```

## Intersection Types

`intersection` type 具有所有类型的功能:

```ts
function extend<T, U>(first: T, second: U): T & U {
  const result = {} as T & U;
  for (const id in first) {
    (result as T)[id] = first[id];
  }
  for (const id in second) {
    if (!Object.prototype.hasOwnProperty.call(result, id)) {
      (result as U)[id] = second[id];
    }
  }

  return result;
}

const x = extend({ a: 'hello' }, { b: 42 });

// 现在 x 拥有了 a 属性与 b 属性
const a = x.a;
const b = x.b;
```

## Conditional Types

- Basic conditional types
  just like `if else` statement.
- Nested conditional types
  just like `switch case` statement.
- Distributive conditional types
  just like `map` statement (`loop` statement) on `union` type.
- Conditional types make TypeScript become real programing type system:
  TypeScript type system is [Turing Complete](https://github.com/microsoft/TypeScript/issues/14833).
- Conditional types in which checked type is `naked type parameter` are called DCT.
- DCT are automatically distributed over union types during instantiation.
- When conditional types act on a generic type,
  they become distributive when given a union type.
- `( A | B | C ) extends T ? X : Y` 相当于
  `(A extends T ? X : Y) | (B extends T ? X : Y) | (B extends T ? X : Y)`.
- 没有被额外包装的联合类型参数, 在条件类型进行判定时会将联合类型分发, 分别进行判断.

```ts
// "string" | "function"
type T1 = TypeName<string | (() => void)>;

// "string" | "object"
type T2 = TypeName<string | string[]>;

// "object"
type T3 = TypeName<string[] | number[]>;
```

```ts
type Naked<T> = T extends boolean ? 'Y' : 'N';
type Wrapped<T> = [T] extends [boolean] ? 'Y' : 'N';

/*
 * 先分发到 Naked<number> | Naked<boolean>
 * 结果是 "N" | "Y"
 */
type Distributed = Naked<number | boolean>;

/*
 * 不会分发 直接是 [number | boolean] extends [boolean]
 * 结果是 "N"
 */
type NotDistributed = Wrapped<number | boolean>;
```

## Mapped Types

### Builtin Mapped Types

- [Builtin mapped types](https://github.com/microsoft/TypeScript/blob/7d60dc1f5db04cc01cba2e1def292432fa41a7ee/src/lib/es5.d.ts#L1468-L1612).

### Basic Mapped Types

```ts
type Readonly<T> = { readonly [P in keyof T]: T[P] };
type Partial<T> = { [P in keyof T]?: T[P] };
type ReadonlyPartial<T> = { readonly [P in keyof T]?: T[P] };
type Required<T> = { [P in keyof T]-?: T[P] };
type Nullable<T> = { [P in keyof T]: T[P] | null };
type NonNullable<T> = T extends null | undefined ? never : T;
type Clone<T> = { [P in keyof T]: T[P] };
type Stringify<T> = { [P in keyof T]: string };
```

### Union Mapped Types

With distributive conditional type:

```ts
type Extract<T, U> = T extends U ? T : never;
type Exclude<T, U> = T extends U ? never : T;
```

### Key Mapped Types

```ts
type Pick<T, K extends keyof T> = { [P in K]: T[P] };
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
type Record<K extends keyof any, T> = { [P in K]: T };
```

### Function Mapped Types

```ts
type Parameters<T extends (...args: any) => any> = T extends (
  ...args: infer P
) => any
  ? P
  : never;

type ConstructorParameters<T extends new (...args: any) => any> =
  T extends new (...args: infer P) => any ? P : never;

type ReturnType<T extends (...args: any) => any> = T extends (
  ...args: any[]
) => infer R
  ? R
  : any;

type InstanceType<T extends new (...args: any) => any> = T extends new (
  ...args: any
) => infer R
  ? R
  : any;

type ThisParameterType<T> = T extends (this: infer U, ...args: any[]) => any
  ? U
  : unknown;
```

### Custom Mapped Types

Combine with:

- `in keyof`.
- `readonly`.
- `?`.
- `-`.
- `as`.
- Template literal types.
- Conditional types.
- Builtin types.
- Other mapped types.
- Other custom types.

```ts
// Removes 'readonly' attributes from a type's properties
type Mutable<Type> = {
  -readonly [Property in keyof Type]: Type[Property];
};

interface LockedAccount {
  readonly id: string;
  readonly name: string;
}

type UnlockedAccount = Mutable<LockedAccount>;
// type UnlockedAccount = {
//   id: string;
//   name: string;
// };
```

```ts
// Mapped types via `as` type
type Getters<Type> = {
  [Property in keyof Type as `get${Capitalize<
    string & Property
  >}`]: () => Type[Property];
};

interface Person {
  name: string;
  age: number;
  location: string;
}

type LazyPerson = Getters<Person>;
// type LazyPerson = {
//   getName: () => string;
//   getAge: () => number;
//   getLocation: () => string;
// }
```

```ts
// Remove the 'kind' property
type RemoveKindField<Type> = {
  [Property in keyof Type as Exclude<Property, 'kind'>]: Type[Property];
};

interface Circle {
  kind: 'circle';
  radius: number;
}

type KindlessCircle = RemoveKindField<Circle>;
// type KindlessCircle = {
//   radius: number;
// }
```

```ts
// Mapped type via conditional type
type ExtractPII<Type> = {
  [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;
};

interface DBFields {
  id: { format: 'incrementing' };
  name: { type: string; pii: true };
}

type ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;
// type ObjectsNeedingGDPRDeletion = {
//   id: false;
//   name: true;
// }
```

## Utility Types

### Null Types

```ts
type Nullish = null | undefined;
type Nullable<T> = T | null;
type NonUndefinedable<A> = A extends undefined ? never : A;
type NonNullable<T> = T extends null | undefined ? never : T;
```

### Boolean Types

```ts
type Falsy = false | '' | 0 | null | undefined;
const isFalsy = (val: unknown): val is Falsy => !val;
```

### Primitive Types

```ts
type Primitive = string | number | boolean | bigint | symbol | null | undefined;

const isPrimitive = (val: unknown): val is Primitive => {
  if (val === null || val === undefined) {
    return true;
  }

  const typeDef = typeof val;

  const primitiveNonNullishTypes = [
    'string',
    'number',
    'bigint',
    'boolean',
    'symbol',
  ];

  return primitiveNonNullishTypes.includes(typeDef);
};
```

### Promise Types

```ts
// TypeScript 4.5.
// Get naked Promise<T> type.
type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;

// A = string.
type A = Awaited<Promise<string>>;

// B = number.
type B = Awaited<Promise<Promise<number>>>;

// C = boolean | number.
type C = Awaited<boolean | Promise<number>>;
```

### Proxy Types

```ts
interface Proxy<T> {
  get(): T;
  set(value: T): void;
}

type Proxify<T> = { [P in keyof T]: Proxy<T[P]> };
```

### Recursive Types

```ts
type DeepReadonly<T> = {
  +readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

type DeepMutable<T> = {
  -readonly [P in keyof T]: T[P] extends object ? DeepMutable<T[P]> : T[P];
};

type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object | undefined ? DeepRequired<T[P]> : T[P];
};
```

- [`PathOf<Form>` complex recursive types](https://mp.weixin.qq.com/s/KJdUdwbLN4g4M7xy34m-fA).

### Lodash Types

```ts
type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;
```

## Type Inference

类型系统在获得足够的信息后,
能将 infer 后跟随的类型参数推导出来,
最后返回这个推导结果:

```ts
type Parameters<T extends (...args: any) => any> = T extends (
  ...args: infer P
) => any
  ? P
  : never;

type ConstructorParameters<T extends new (...args: any) => any> =
  T extends new (...args: infer P) => any ? P : never;

type ReturnType<T extends (...args: any) => any> = T extends (
  ...args: any[]
) => infer R
  ? R
  : any;

type InstanceType<T extends new (...args: any) => any> = T extends new (
  ...args: any
) => infer R
  ? R
  : any;
```

```ts
const foo = (): string => {
  return 'sabertaz';
};

// string
type FooReturnType = ReturnType<typeof foo>;
```

## Type Guard

### Discriminated Union Type Guard

```ts
interface Teacher {
  kind: 'Teacher';
  teacherId: string;
}

interface Student {
  kind: 'Student';
  studentId: string;
}

type Attendee = Teacher | Student;

function getId(attendee: Attendee) {
  switch (attendee.kind) {
    case 'Teacher':
      // %inferred-type: { kind: "Teacher"; teacherId: string; }
      return attendee.teacherId;
    case 'Student':
      // %inferred-type: { kind: "Student"; studentId: string; }
      return attendee.studentId;
    default:
      throw new Error('Unsupported type');
  }
}
```

### Never Type Guard

- The `never` type is assignable to every type.
- No type is assignable to `never` (except `never` itself).

```ts
interface Triangle {
  kind: 'triangle';
  sideLength: number;
}

type Shape = Circle | Square | Triangle;

function getArea(shape: Shape) {
  switch (shape.kind) {
    case 'circle':
      return Math.PI * shape.radius ** 2;
    case 'square':
      return shape.sideLength ** 2;
    default: {
      // Type 'Triangle' is not assignable to type 'never'.
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
    }
  }
}
```

Exhaustiveness checks:

```ts
class UnsupportedValueError extends Error {
  constructor(value: never) {
    super(`Unsupported value: ${value}`);
  }
}

function toGerman4(value: NoYesStrings): string {
  switch (value) {
    case 'Yes':
      return 'Ja';
    default:
      // @ts-expect-error: Argument of type '"No"'
      // is not assignable to parameter of type 'never'. (2345)
      throw new UnsupportedValueError(value);
  }
}
```

### Type Predicate

`is` keyword for `value` type predicate:

```ts
type Falsy = false | '' | 0 | null | undefined;
const isFalsy = (val: unknown): val is Falsy => !val;
```

```ts
function isNotNullish<T>(value: T): value is NonNullable<T> {
  return value !== undefined && value !== null;
}

// %inferred-type: (number | null | undefined)[]
const mixedValues = [1, undefined, 2, null];

// %inferred-type: number[]
const numbers = mixedValues.filter(isNotNullish);
```

```ts
/**
 * A partial implementation of the `typeof` operator.
 */
function isTypeof(value: any, typeString: 'boolean'): value is boolean;
function isTypeof(value: any, typeString: 'number'): value is number;
function isTypeof(value: any, typeString: 'string'): value is string;
function isTypeof(value: any, typeString: string): boolean {
  return typeof value === typeString;
}

const value: unknown = {};

if (isTypeof(value, 'boolean')) {
  // %inferred-type: boolean
  console.log(value);
}
```

## Type Assertion

- `<type>`.
- `as type`.

> `as` is better in `.jsx`

```ts
let foo: any;
const bar = foo as string; // 现在 bar 的类型是 'string'
```

```ts
function handler(event: Event) {
  const mouseEvent = event as MouseEvent;
}
```

## Type System

TypeScript type system:

- [Turing complete](https://github.com/microsoft/TypeScript/issues/14833) type system.
- Structural type system: type checking focuses on shape (`Duck Typing`).

### Covariant

Covariant (协变性):

Type `T` is **covariant** if having `S <: P`,
then `T<S> <: T<P>`.

```ts
type IsSubtype<S, P> = S extends P ? true : false;

type T1 = IsSubtype<Admin, User>;
// type T1 = true

type T2 = IsSubtype<Promise<Admin>, Promise<User>>;
// type T2 = true

type T3 = IsSubtype<'Hello', string>;
// type T3 = true

type T4 = IsSubtype<Capitalize<'Hello'>, Capitalize<string>>;
// type T4 = true
```

### Contravariant

Contravariant (逆变性):

Type `T` is **contravariant** if having `S <: P`,
then `T<P> <: T<S>`.

```ts
type IsSubtype<S, P> = S extends P ? true : false;

type Func<Param> = (param: Param) => void;

type T1 = IsSubtype<Admin, User>;
// type T1 = true

type T2 = IsSubtype<Func<Admin>, Func<User>>;
// type T2 = false

type T3 = IsSubtype<Func<User>, Func<Admin>>;
// type T3 = true
```

```ts
const logAdmin: Func<Admin> = (admin: Admin): void => {
  console.log(`Name: ${admin.userName}`);
  console.log(`Is super admin: ${admin.isSuperAdmin.toString()}`);
};

const logUser: Func<User> = (user: User): void => {
  console.log(`Name: ${user.userName}`);
};

const admin = new Admin('admin1', true);

let logger: Func<Admin>;

logger = logUser;
logger(admin); // OK

logger = logAdmin;
logger(admin); // OK

const user = new User('user1');

let logger: Func<User>;

logger = logUser;
logger(user); // OK

logger = logAdmin;
// Type 'Func<Admin>' is not assignable to type 'Func<User>'.
//   Property 'isSuperAdmin' is missing in type 'User' but required in type 'Admin'.
logger(user); // Oops! `user.isSuperAdmin` is undefined.
```

### Type Gymnastics

[Type programming](https://exploringjs.com/tackling-ts/ch_computing-with-types-overview.html):

| Level         | Environment  | Operands       | Operations    |
| ------------- | ------------ | -------------- | ------------- |
| Program level | Runtime      | Values         | Functions     |
| Type level    | Compile time | Specific types | Generic types |
