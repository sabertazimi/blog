name: Agent

on:
  issue_comment:
    types: [created]

env:
  TRIGGER_KEYWORDS: '@claude,@agent'

jobs:
  agent:
    name: Agent
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      pull-requests: write
      contents: read
      issues: read
    if: |
      github.event.issue.pull_request &&
      !contains(github.event.comment.user.login, 'renovate') &&
      !contains(github.event.comment.user.login, 'dependabot') &&
      !contains(github.event.comment.user.login, 'imgbot')
    steps:
      - name: Verify authorization
        id: auth
        uses: actions/github-script@v8
        with:
          script: |
            const commentUser = context.payload.comment.user.login;
            const repoOwner = context.repo.owner;
            const commenter = commentUser.toLowerCase();
            const owner = repoOwner.toLowerCase();

            // Check if commenter is the repo owner
            if (commenter === owner) {
              core.info('✓ Authorized: Repo owner');
              core.setOutput('authorized', 'true');
              return;
            }

            // Check if commenter is a collaborator
            try {
              const permissions = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: commentUser
              });

              const permission = permissions.data.permission;
              const isAuthorized = ['admin', 'write', 'maintain'].includes(permission);

              if (isAuthorized) {
                core.info(`✓ Authorized: ${permission} permission`);
                core.setOutput('authorized', 'true');
              } else {
                core.info(`✗ Unauthorized: ${permission} permission`);
                core.setOutput('authorized', 'false');
              }
            } catch (error) {
              core.warning(`Failed to check permissions: ${error.message}`);
              core.setOutput('authorized', 'false');
            }

      - name: Parse command
        id: parse
        uses: actions/github-script@v8
        with:
          script: |
            const commentBody = context.payload.comment.body;
            const triggerKeywords = process.env.TRIGGER_KEYWORDS.split(',');

            core.info(`Comment body: ${commentBody}`);
            core.info(`Trigger keywords: ${triggerKeywords.join(', ')}`);

            let triggerKeyword = null;
            let command = null;

            // Find which trigger keyword was used
            for (const keyword of triggerKeywords) {
              const trimmedKeyword = keyword.trim();
              if (commentBody.toLowerCase().startsWith(trimmedKeyword.toLowerCase())) {
                triggerKeyword = trimmedKeyword;
                // Extract everything after the trigger keyword
                const afterKeyword = commentBody.slice(trimmedKeyword.length).trim();
                command = afterKeyword;
                break;
              }
            }

            if (!triggerKeyword) {
              core.info('No trigger keyword found');
              core.setOutput('triggered', 'false');
              return;
            }

            core.info(`✓ Triggered by: ${triggerKeyword}`);
            core.info(`Command: ${command}`);
            core.setOutput('triggered', 'true');
            core.setOutput('trigger_keyword', triggerKeyword);
            core.setOutput('command', command);

            // Determine command type
            if (command.toLowerCase().startsWith('/review')) {
              core.setOutput('command_type', 'review');
            } else if (command.trim() === '') {
              core.warning('No command provided');
              core.setOutput('command_type', 'empty');
            } else {
              core.setOutput('command_type', 'direct');
            }
        env:
          TRIGGER_KEYWORDS: ${{ env.TRIGGER_KEYWORDS }}

      - name: Checkout repository
        if: |
          steps.auth.outputs.authorized == 'true' &&
          steps.parse.outputs.triggered == 'true' &&
          steps.parse.outputs.command_type != 'empty'
        uses: actions/checkout@v6
        with:
          submodules: true
          fetch-depth: 0

      - name: Setup pnpm
        if: |
          steps.auth.outputs.authorized == 'true' &&
          steps.parse.outputs.triggered == 'true' &&
          steps.parse.outputs.command_type != 'empty'
        uses: pnpm/action-setup@v3

      - name: Setup Node environment
        if: |
          steps.auth.outputs.authorized == 'true' &&
          steps.parse.outputs.triggered == 'true' &&
          steps.parse.outputs.command_type != 'empty'
        uses: actions/setup-node@v6
        with:
          node-version: lts/*
          check-latest: true
          architecture: x64
          registry-url: https://registry.npmjs.org/
          cache: pnpm

      - name: Install dependencies
        if: |
          steps.auth.outputs.authorized == 'true' &&
          steps.parse.outputs.triggered == 'true' &&
          steps.parse.outputs.command_type != 'empty'
        run: |
          pnpm install

      - name: Install Claude Code
        if: |
          steps.auth.outputs.authorized == 'true' &&
          steps.parse.outputs.triggered == 'true' &&
          steps.parse.outputs.command_type != 'empty'
        run: |
          npm install -g @anthropic-ai/claude-code

      - name: Configure Claude Code
        if: |
          steps.auth.outputs.authorized == 'true' &&
          steps.parse.outputs.triggered == 'true' &&
          steps.parse.outputs.command_type != 'empty'
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('node:fs/promises');
            const path = require('node:path');
            core.startGroup('Configure Claude Code');

            // Validate secrets
            if (!process.env.ANTHROPIC_AUTH_TOKEN) {
              core.setFailed('ANTHROPIC_AUTH_TOKEN secret is not set');
              return;
            }

            const claudeDir = path.join(process.env.HOME, '.claude');
            core.debug(`Creating directory: ${claudeDir}`);
            await io.mkdirP(claudeDir);

            // Write onboarding config
            await fs.writeFile(
              path.join(claudeDir, '.claude.json'),
              JSON.stringify({ hasCompletedOnboarding: true })
            );

            // Write settings with secrets from env
            const model = process.env.ANTHROPIC_MODEL;
            await fs.writeFile(
              path.join(claudeDir, 'settings.json'),
              JSON.stringify({
                env: {
                  ANTHROPIC_AUTH_TOKEN: process.env.ANTHROPIC_AUTH_TOKEN,
                  ANTHROPIC_BASE_URL: process.env.ANTHROPIC_BASE_URL,
                  ANTHROPIC_MODEL: model,
                  ANTHROPIC_SMALL_FAST_MODEL: model,
                  ANTHROPIC_DEFAULT_OPUS_MODEL: model,
                  ANTHROPIC_DEFAULT_SONNET_MODEL: model,
                  ANTHROPIC_DEFAULT_HAIKU_MODEL: model,
                  API_TIMEOUT_MS: '3000000',
                  CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC: '1',
                },
              })
            );

            core.info('✓ Claude Code configured successfully');
            core.endGroup();
        env:
          ANTHROPIC_AUTH_TOKEN: ${{ secrets.ANTHROPIC_AUTH_TOKEN }}
          ANTHROPIC_BASE_URL: ${{ secrets.ANTHROPIC_BASE_URL }}
          ANTHROPIC_MODEL: ${{ secrets.ANTHROPIC_MODEL }}

      - name: Run Claude Code
        if: |
          steps.auth.outputs.authorized == 'true' &&
          steps.parse.outputs.triggered == 'true' &&
          steps.parse.outputs.command_type != 'empty'
        env:
          GH_TOKEN: ${{ github.token }}
          COMMAND_TYPE: ${{ steps.parse.outputs.command_type }}
          COMMAND: ${{ steps.parse.outputs.command }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          echo 'Running Claude Code...'

          if [ "$COMMAND_TYPE" = "review" ]; then
            echo "Executing /review command..."

            claude -p "
            REPO: ${{ github.repository }}
            PR NUMBER: $ISSUE_NUMBER

            You are performing an automated code review on this pull request.

            Please:
            1. Use \`gh pr diff\` to see the changes
            2. Use \`gh pr view\` to get PR details
            3. Analyze the code for:
               - CLAUDE.md guidelines compliance (read CLAUDE.md if it exists)
               - Bugs and issues introduced in this PR
               - Security vulnerabilities
               - Performance concerns
               - Code quality issues

            4. For each issue found:
               - Verify it is actually introduced by this PR (not pre-existing)
               - Score your confidence 0-100
               - Only report issues with 80+ confidence

            5. Call \`gh pr review\` ONCE at the end with:
               - Flag: \`--comment\`, \`--approve\`, or \`--request-changes\` based on findings
               - Body format:
                 \`\`\`markdown
                 ## Code review
                 Found <N> issues:
                 1. <Issue description> (confidence: <score>)
                    <file-with-link>
                 ...
                 \`\`\`
               - For code suggestions, use the \`+/-\` suggestion format for easy apply
               - For code links: https://github.com/<owner>/<repo>/blob/<full-sha>/<path>#L<start>-L<end>
            " || true

          elif [ "$COMMAND_TYPE" = "direct" ]; then
            echo "Executing direct command: $COMMAND"

            claude -p "
            REPO: ${{ github.repository }}
            PR/ISSUE NUMBER: $ISSUE_NUMBER

            The user has requested you to execute the following command:
            $COMMAND

            Please execute this command and POST YOUR RESPONSE AS A PR COMMENT using:
            gh pr comment $ISSUE_NUMBER --body '<your response>'

            Do not just output to stdout - you must post it as a comment.
            " || true

          else
            echo "Unknown command type encountered: $COMMAND_TYPE"
            gh pr comment "$ISSUE_NUMBER" --body "⚠️ An internal error occurred while processing your request: unknown command type \`$COMMAND_TYPE\`. Please contact a maintainer to check the workflow configuration."
            exit 1
          fi

          echo '✓ Command completed'
